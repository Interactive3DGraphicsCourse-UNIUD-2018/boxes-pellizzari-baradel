<html>
	<head>
		<title>Progetto 3D 2018 - with lights and textures</title>
		<style>

		body {
			font-family: Monospace;
			background-color: #71b2cf;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

		.right {
			position: absolute;
			right: 0px;
			width: 80px;
		}

	</style>

		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="src/Macchina.js"></script>
		<script src="src/Strada.js"></script>
		<script src="src/Ausiliarie.js"></script>
		<script src="src/Ostacoli.js"></script>
		<script src="src/MovimentoMacchina.js"></script>
		<script src="src/Collisioni.js"></script>
		<script src="src/Animazioni.js"></script>
	</head>
	<body>
		<div class="right", id="punteggio" > </div>

		<div class="contenitore" id="contenitoreBottone" >
			<button id="bottone" onclick="nuovaPartita()" >Nuova partita</button>
		</div>

		<script>

		document.getElementById("contenitoreBottone").style.display = "none";  // elimino/nascondo l'elemento (bottone di fine partita) dalla scena

		// VARIABILI PER LA CREAZIONE DELLA SCENA
		var scene, camera, renderer, controls, stats, tabellaPunti, punti;
		var pivotMacchina;  // pivot che contiene la macchina e la camera, così si muovono insieme
		var yFineRuote;  // punto sull'asse y in cui iniziano le ruote
		var lunghezzaStrada = 10000;

		// VARIABILI PER LE ANIMAZIONI
		var asteroidi = new Array();
		var contatoreAsteroide = 0;
		var numAsteroide = 0;
		var velocitaDiscesa = 0;
		var mulini = new Array();
		var posizioneZMulini = new Array();
		var contatoreMulini = 0;
		var numMulini = 0;

		// VARIABILI PER IL MOVIMENTO DELLA MACCHINA
		var xDestra, xSinistra;  // possibili valori della posizione x della macchina durante la partita (sulla strada)
		var muoviDx, muoviSx;  // variabili booleane che servono per il movimento della macchina a destra e a sinistra
		var spostamentoMacchinaZ = 0.6;  // quanto velocemente avanza la macchina verso -z
		var spostamentoMacchinaX;  // quanto la macchina si sposta su x alla pressione dei tasti direzionali
		var fasciaPosizioneMacchina = 0;  // quanto lontano si trova la macchina dall'origine
		var offsetMacchinaZ = 1.75;  // distanza fra centro della macchina e fine delle ruote (su z)
		var offsetMacchinaX = 0.75;  // distanza fra centro della macchina e fine della fiancata (su x)

		// VARIABILI CHE SERVONO PER LE COLLISIONI
		gameOver = false; //Quando un ostacolo viene colpito, questa variabile diventa true e il gioco ha termine
		spazioFraOstacoli = 50;
		numeroOstacoli = (lunghezzaStrada/spazioFraOstacoli) -2;  // -2 perchè in posizione 0 e in fondo alla pista non metto ostacoli
		posizioneOstacoli = new Array(); // Array per la gestione delle collisioni, ostacoli[i] = 1 (Destra), -1(Sinistra)
		tipoOstacoli = new Array(); //Array per la gestione delle collisione, indica solo il tipo di ostacolo con le stringhe (es. "asteroide")

		// Variabili per i PowerUp
		numeroPowerUp = 49; //Sono presenti 49 powerUp in pista, uno ogni 4 ostacoli;
		angoloOscillazioneVerticale = 0;

		// Variabili ausiliarie
		var rotazioneAttuale = 0;
		var bottoneInserito = false;
		punteggio = 0;  // variabile per tenere conto dei punti in base alla distanza percorsa

		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 400 );
			pivotMacchina = new THREE.Object3D();

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0x71b2cf );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );

			camera.position.set(2,2,12);
			camera.lookAt( new THREE.Vector3(0,0,0));
			pivotCamera = new THREE.Object3D();
			pivotCamera.add(camera);

			yFineRuote = inserisciMacchina();
			pivotMacchina.add(pivotCamera);
			scene.add(pivotMacchina);
			scene.fog = new THREE.Fog( 0x71b2cf, 0.1, 400 );

			inserisciStrada();  // inserisco strada con gli ostacoli
			inserisciLuceEmisferica();
			arrayOmini = new Array();
			arrayVelOmini = new Array();
			inserisciOmini();
			inserisciOminiStart();
			inserisciOminiEnd();

			pivotMacchina.position.x = scegliLato("interno");  // posiziono la macchina su uno dei due lati (a caso)
			pivotMacchina.position.z = -(3 + 0.5)/2;  // posiziono la macchina all'inizio della strada (lunghezza macchina + lunghezza ruote)/2

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );

			// Aggiungo i controlli
			controls = new THREE.OrbitControls( camera );
			controls.enableKeys = false;  // disabilito la tastiera, così posso giocare al minigioco senza spostare la camera quando premo le frecce
			controls.addEventListener( 'change', Render );


			/* Script per la pressione delle chiavi, sono state usate solo le chiavi
			*  dei tasti dirazionali laterali (Destra, Sinistra, A, D);
			*/
			var onKeyDown = function ( event ) {
				switch ( event.keyCode ) {
					// se premo A oppure la freccia sinistra
					case 37: // left
					case 65: // a
						muoviDx = false;
						muoviSx = true;
						break;
					// se premo D oppure la freccia destra
					case 39: // right
					case 68: // d
						muoviSx = false;
						muoviDx = true;
						break;
				}
			};

			document.addEventListener( 'keydown', onKeyDown);

			muoviSx = false;  // inizialmente tutti a false
			muoviDx = false;

			// TEMP Creazione e test dei PowerUp
			powerUpAttivi = new Array();
			powerUpInScena = new Array();
			powerUpInScenaTipo = new Array();
			powerUpAttivi.push(0); // TEMP per indicare la z mancante per il moliplicatore;
			powerUpAttivi.push(0); // TEMP per indicare i colpi di cannone restanti;
			powerUpAttivi.push(0); // TEMP per indicare la presenza o meno di uno scudo; (0 assente, 1 presente);

			aggiungiPowerUp();
		}  // Start()

		/*
		*  Aggiunge i powerUp alla scena ponendoli con una certa probabilita'
		*  nello spazio fra due ostacoli in modo che sia possibile prenderli;
		*/
		function aggiungiPowerUp(){
			var distanzaPowerUp = 10000 / (numeroPowerUp+1);
			var tipologiePowerUp = 3; //Tipologie Possibili di powerUp; TEMP attualmente 3;
			for(var i = 0; i < numeroPowerUp - 1; i++){ // -2 perche' 48+1*200+25 = 9825, non ce ne starebbero altri;
				var prossimoPowerUp = randomConRange(0, tipologiePowerUp-1);
				switch (prossimoPowerUp){
					case 0:
					aggiungiMoltiplicatorePunti((i+1)*distanzaPowerUp + 25); //Aggiungo il powerUp a 200*i + 25 per evitare gli ostacoli
					break;
					case 1:
					aggiungiCannone((i+1)*distanzaPowerUp + 25);
					break;
					case 2:
					aggiungiScudo((i+1)*distanzaPowerUp + 25);
					break;
				}
			}
		}

		// Aggiunge un moltiplicatore di punteggio alla scena a distanza z;
		function aggiungiMoltiplicatorePunti(z){
			var x = scegliLato();
			var geometriaStella = new THREE.BoxGeometry(2,2,2); //TEMP per testare;
			var materialeStella = new THREE.MeshPhongMaterial({color: 0xffff00});
			var moltiplicatore = new THREE.Mesh(geometriaStella, materialeStella);

			moltiplicatore.position.set(x/7.2, 1, -z);

			scene.add(moltiplicatore);
			powerUpInScena.push(moltiplicatore);
			powerUpInScenaTipo.push("stella");
		}

		// Aggiunge il cannone alla scena e agli array
		function aggiungiCannone(z){
			var x = scegliLato();
			var geometriaCannone = new THREE.BoxGeometry(2,2,2); //TEMP per testare;
			var materialeCannone = new THREE.MeshPhongMaterial({color: 0x555555});
			var cannoneMesh = new THREE.Mesh(geometriaCannone, materialeCannone);

			cannoneMesh.position.set(x/7.2, 1, -z);

			scene.add(cannoneMesh);
			powerUpInScena.push(cannoneMesh);
			powerUpInScenaTipo.push("cannone");
		}

		// Aggiunge lo scudo alla scena e agli array
		function aggiungiScudo(z){
			var x = scegliLato();
			var geometriaScudo = new THREE.BoxGeometry(2,2,2); //TEMP per testare;
			var materialeScudo = new THREE.MeshPhongMaterial({color: 0xff0000}); // TEMP di colore rosso per test;
			var scudoMesh = new THREE.Mesh(geometriaScudo, materialeScudo);

			scudoMesh.position.set(x/7.2, 1, -z);

			scene.add(scudoMesh);
			powerUpInScena.push(scudoMesh);
			powerUpInScenaTipo.push("scudo");
		}

		function aggiornaPowerUp(){
			for(var i = 0; i < powerUpInScena.length; i++){
				powerUpInScena[i].position.y = Math.sin(angoloOscillazioneVerticale) + 0.7; //Oscillazione verticale del powerUp;
				angoloOscillazioneVerticale = angoloOscillazioneVerticale%(Math.PI*2) + 0.002;
				powerUpInScena[i].rotateY(0.05);
			}
		}

		function animaScena(){
			// AGGIORNO IL FUOCO
			aggiornaFuoco(arrFuoco);
			aggiornaOmini();
			aggiornaPowerUp();
			if(!gameOver){
				// ANIMO GLI EVENTUALI ASTEROIDI
				controllaAsteroide();
				// ANIMA MULINO
				controllaMulino();
				// VERIFICO CHE NON CI SIANO COLLISIONI
				controllaCollisioni();
				controllaCollisioniBonus();

				console.log(powerUpAttivi[0]);
				console.log(powerUpAttivi[1]);
				console.log(powerUpAttivi[2]);

				// CALCOLO LO SPOSTAMENTO CHE DOVREBBE FARE LA MACCHINA
				scegliSpostamentoMacchina(pivotMacchina.position.z);  // in base alla posizione della macchina...
				if(!gameOver){
					pivotMacchina.position.z -= spostamentoMacchinaZ;  // imposto la sua velocità
				}
				// IN BASE AI TASTI PREMUTI VADO AVANTI (se non si verifica il gameOver)
				if(muoviSx){
					muoviMacchinaSx(pivotMacchina);
				}
				if(muoviDx){
					muoviMacchinaDx(pivotMacchina);
				}
				// ALL'ARRIVO, SE VINCO FACCIO RUOTARE LA TELECAMERA ATTORNO ALLA MACCHINA E INSERISCO IL BOTTONE DI NUOVA PARTITA
				if(pivotMacchina.position.z < -10000){
					rotateCamera();
					controllaBottone();
				}
			}else{  // gameOver
				// FACCIO RUOTARE LA TELECAMERA ATTORNO ALLA MACCHINA E INSERISCO IL BOTTONE DI NUOVA PARTITA
				rotateCamera();
				controllaBottone();
			}
			stampaPunteggio();
		}

		// UPDATE E CICLO DI RENDER

		function Update() {
			requestAnimationFrame( Update );
			controls.update();
			stats.update();
			Render();
		}

		function Render() {
			animaScena();
			renderer.render(scene, camera);
		}

		Start();
		Update();

		</script>
	</body>
</html>
